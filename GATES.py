# from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister,Aer,BasicAer,execute
# from qiskit.visualization import plot_histogram, plot_state_qsphere, plot_bloch_multivector, plot_bloch_vector
# import numpy as np

print('And gate:')

# # def NOT(inp):
# #     qc = QuantumCircuit(1, 1) 
# #     qc.reset(0)
# from qiskit import QuantumCircuit, Aer, execute

# qc = QuantumCircuit(3, 1)
# qc.ccx(0, 1, 2)  

# qc.measure(2, 0)

# simulator = Aer.get_backend('qasm_simulator')
# result = execute(qc, simulator, shots=1024).result()
# counts = result.get_counts(qc)

# for qc in range (0,3):
#     counts.(1++qc)
#     print(counts)


print('AND gate:')

# from qiskit import QuantumCircuit, Aer, execute

# import keys
# qc = QuantumCircuit(3, 1)

# qc.ccx(0, 1, 2)  
# qc.measure(1, 0)  

# simulator = Aer.get_backend('qasm_simulator')
# result = execute(qc, simulator, shots=1024).result()
# counts = result.get_counts(qc)


# for input_state, output, output.keys in counts.items():
#     binary_output = '0' if '0' in output.keys() else '1'
#     print(f"{input_state}: {{{binary_output} : 1024}}")



# from qiskit import QuantumCircuit, Aer, execute
# from qiskit.visualization import plot_histogram
# import keys

# qc = QuantumCircuit(3, 1) 


# qc.ccx(0, 1, 2)  


# qc.measure(2, 0)


# simulator = Aer.get_backend('qasm_simulator')
# result = execute(qc, simulator, shots=1024).result()
# counts = result.get_counts(qc)

# print('Input | Output')

# for input_state, count in counts.items():
#     input_str = ' | '.join(list(input_state))
#     output_str = list(count.keys())[0]
#     print(f' {input_str} | {output_str}')


print ('NAND gate')




print ('OR gate')


print ('XOR gate')
















# from qiskit import QuantumCircuit, Aer, execute

# qc = QuantumCircuit(3, 1)

# qc.ccx(0, 1, 2)  
# qc.measure(1, 0) 

# count=0

# simulator = Aer.get_backend('qasm_simulator')
# result = execute(qc, simulator, shots=1024).result()
# counts = result.get_counts(qc)

# for input_state, output in counts.items():
#     for i in range (0,4):
#         print(f"{input_state}: {output}")
        
# f

